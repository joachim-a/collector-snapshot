syntax = "proto3";

import "google/protobuf/timestamp.proto";

package pganalyze.collector;

// Format Version: 1.0.0

// DEFINITIONS
//
// - Reference: Term(s) that can be UPSERTed into the monitoring system, and is
//              referenced by its list index within other parts of the snapshot.
//
//              The goal here is that we can do a two-step processing of the data,
//              first we create/find all references and get their IDs, then we
//              just COPY all statistics into the database, replacing idx for ID.
//
// - Information: Data that is attached to a reference, at most once, and is not stored historically.
//                When processing this data can simply be UPDATEd after the initial UPSERT.
//
//                In some cases this data might also be provided at less frequent intervals than Statistics.
//
// - Statistic: Data that is attached to a reference, at most once, and is stored historically.
//              When processing this data can be COPYed after the initial UPSERT.
//
//              In case the input data is a counter, this will be normalized by the collector
//              before the snapshot is created, the recipient does not need to look at previous
//              values to find out what happened.
//
// - Event: Data that is attached to a reference, and can occur multiple times for one reference within the snapshot.
//          When processing this data can be COPYed after the initial UPSERT.

message FullSnapshot {
  // Basic information about this snapshot
  int32 snapshot_version_major = 1;
  int32 snapshot_version_minor = 2;
  string collector_version = 3;

  string snapshot_uuid = 10;
  google.protobuf.Timestamp collected_at = 11;
  int32 collected_interval_secs = 12;

  // Per server (and hence snapshot)
  PostgresVersion postgres_version = 101;

  repeated RoleReference role_references = 102;
  repeated DatabaseReference database_references = 103;

  repeated RoleInformation role_informations = 110;
  repeated DatabaseInformation database_informations = 111;

  repeated LogLine logs = 120;
  repeated Backend backends = 121;
  repeated Setting settings = 122;

  // Per database
  repeated QueryReference query_references = 200;
  repeated RelationReference relation_references = 201;
  repeated IndexReference index_references = 202;
  repeated FunctionReference function_references = 203;

  repeated QueryInformation query_informations = 210;
  repeated QueryStatistic query_statistics = 211;
  repeated QueryExplain query_explains = 212;

  repeated RelationInformation relation_informations = 220;
  repeated RelationStatistic relation_statistics = 221;
  repeated RelationBloatStatistic relation_bloat_statistics = 222;
  repeated RelationEvent relation_events = 223;

  repeated IndexInformation index_informations = 224;
  repeated IndexStatistic index_statistics = 225;
  repeated IndexBloatStatistic index_bloat_statistics = 226;

  repeated FunctionInformation function_informations = 227;
  repeated FunctionStatistic function_statistics = 228;
}

message NullString {
  bool valid = 1;
  string value = 2;
}

message NullTimestamp {
  bool valid = 1;
  google.protobuf.Timestamp value = 2;
}

// PER SERVER

message RoleReference {
  string name = 1; // Role name
}

message DatabaseReference {
  string name = 1; // Database name
}

message RoleInformation {
  int32 role_idx = 1;

  bool inherit = 2;           // Role automatically inherits privileges of roles it is a member of
  bool login = 3;             // Role can log in. That is, this role can be given as the initial session authorization identifier
  bool create_db = 4;         // Role can create databases
  bool create_role = 5;       // Role can create more roles
  bool super_user = 6;        // Role has superuser privileges
  bool replication = 7;       // Role can initiate streaming replication and put the system in and out of backup mode.
  bool bypass_rls = 8;        // Role bypasses every row level security policy, see https://www.postgresql.org/docs/9.5/static/ddl-rowsecurity.html
  int32 connection_limit = 9; // For roles that can log in, this sets maximum number of concurrent connections this role can make. -1 means no limit.

  NullTimestamp password_valid_until = 10; // Password expiry time (only used for password authentication); null if no expiration
  repeated string config = 11;             // Role-specific defaults for run-time configuration variables
  repeated int32 member_of = 12;           // List of roles that this role is a member of (i.e. whose permissions it inherits)
}

message DatabaseInformation {
  int32 database_idx = 1;

  int32 owner_role_idx = 2;   // Owner of the database, usually the user who created it
  string encoding = 3;        // Character encoding for this database
  string collate = 4;         // LC_COLLATE for this database
  string c_type = 5;          // LC_CTYPE for this database
  bool is_template = 6;       // If true, then this database can be cloned by any user with CREATEDB privileges; if false, then only superusers or the owner of the database can clone it.
  bool allow_connections = 7; // If false then no one can connect to this database. This is used to protect the template0 database from being altered.
  int32 connection_limit = 8; // Sets maximum number of concurrent connections that can be made to this database. -1 means no limit.

  // All transaction IDs before this one have been replaced with a permanent ("frozen") transaction ID in this database.
	// This is used to track whether the database needs to be vacuumed in order to prevent transaction ID wraparound or to
	// allow pg_clog to be shrunk. It is the minimum of the per-table pg_class.relfrozenxid values.
  uint32 frozen_xid = 9;

  // All multixact IDs before this one have been replaced with a transaction ID in this database.
	// This is used to track whether the database needs to be vacuumed in order to prevent multixact ID wraparound or to
	// allow pg_multixact to be shrunk. It is the minimum of the per-table pg_class.relminmxid values.
  uint32 minimum_multixact_xid = 10;
}

message PostgresVersion {
  string full = 1;
  string short = 2;
  int64 numeric = 3;
}

message LogLine {
  int64 occurred_at = 1;
  SourceType source = 2;
  NullString client_ip = 3;
  string log_level = 4;
  int32 backend_pid = 5;
  string content = 6;
  repeated LogLine additional_lines = 7;

  enum SourceType {
    PostgresSource = 0;
    AmazonRdsSource = 1;
  }
}

message Setting {
  string name = 1;
  string current_value = 2;
  NullString unit = 3;
  NullString boot_value = 4;
  NullString reset_value = 5;
  NullString source = 6;
  NullString source_file = 7;
  NullString source_line = 8;
}

message Backend {
  int64 pid = 1;
  string username = 2;
  string application_name = 3;
  string client_addr = 4;

  google.protobuf.Timestamp backend_start = 5;
  google.protobuf.Timestamp xact_start = 6;
  google.protobuf.Timestamp query_start = 7;
  google.protobuf.Timestamp state_change = 8;

  bool waiting = 9;
  string state = 10;
  string normalized_query = 11;
}

message System {
  // TODO
}

// PER DATABASE

message RelationReference {
  int32 database_idx = 1;
  string schema_name = 2;
  string relation_name = 3;
}

message IndexReference {
  int32 database_idx = 1;
  string schema_name = 2;
  string index_name = 3;
}

message FunctionReference {
  int32 database_idx = 1;
  string schema_name = 2;
  string function_name = 3;
  string arguments = 4;
}

message QueryReference {
  int32 database_idx = 1;
  int32 role_idx = 2;
  bytes fingerprint = 3;
}

message QueryInformation {
  int32 query_idx = 1;

  string normalized_query = 2;
  repeated int64 query_ids = 3;
}

message QueryStatistic {
  int32 query_idx = 1;

  int64 calls = 2;
  double total_time = 3;
  int64 rows = 4;
  int64 shared_blks_hit = 5;
  int64 shared_blks_read = 6;
  int64 shared_blks_dirtied = 7;
  int64 shared_blks_written = 8;
  int64 local_blks_hit = 9;
  int64 local_blks_read = 10;
  int64 local_blks_dirtied = 11;
  int64 local_blks_written = 12;
  int64 temp_blks_read = 13;
  int64 temp_blks_written = 14;
  double blk_read_time = 15;
  double blk_write_time = 16;
}

message QueryExplain {
  int32 query_idx = 1;

  int64 occurred_at = 4;
  double runtime = 5;
  string explain_output = 6;
  string explain_error = 7;
}

message RelationInformation {
  int32 relation_idx = 1;

  string relation_type = 2;
  NullString view_definition = 3;

  repeated Column columns = 4;
  repeated Constraint constraints = 5;

  string persistence_type = 6;
  int32 fillfactor = 7;
  bool has_oids = 8;
  bool has_inheritance_children = 9;
  bool has_toast = 10;

  uint32 frozen_xid = 11;
  uint32 minimum_multixact_xid = 12;

  message Column {
    string name = 2;
    string data_type = 3;
    NullString default_value = 4;
    bool not_null = 5;
    int32 position = 6;
  }

  message Constraint {
    int32 foreign_relation_idx = 1;     // If a foreign key, the referenced table

    string name = 2;                    // Constraint name (not necessarily unique!)
    string type = 3;                    // c = check constraint, f = foreign key constraint, p = primary key constraint, u = unique constraint, t = constraint trigger, x = exclusion constraint
    string constraint_def = 4;          // Human-readable representation of the expression
    repeated int32 columns = 5;         // If a table constraint (including foreign keys, but not constraint triggers), list of the constrained columns
    repeated int32 foreign_columns = 6; // If a foreign key, list of the referenced columns
    string foreign_update_type = 7;     // Foreign key update action code: a = no action, r = restrict, c = cascade, n = set null, d = set default
    string foreign_delete_type = 8;     // Foreign key deletion action code: a = no action, r = restrict, c = cascade, n = set null, d = set default
    string foreign_match_type = 9;      // Foreign key match type: f = full, p = partial, s = simple
  }
}

message RelationStatistic {
  int32 relation_idx = 1;

  int64 size_bytes = 2;
  int64 seq_scan = 3;             // Number of sequential scans initiated on this table
  int64 seq_tup_read = 4;         // Number of live rows fetched by sequential scans
  int64 idx_scan = 5;             // Number of index scans initiated on this table
  int64 idx_tup_fetch = 6;        // Number of live rows fetched by index scans
  int64 n_tup_ins = 7;            // Number of rows inserted
  int64 n_tup_upd = 8;            // Number of rows updated
  int64 n_tup_del = 9;            // Number of rows deleted
  int64 n_tup_hot_upd = 10;       // Number of rows HOT updated (i.e., with no separate index update required)
  int64 n_live_tup = 11;          // Estimated number of live rows
  int64 n_dead_tup = 12;          // Estimated number of dead rows
  int64 n_mod_since_analyze = 13; // Estimated number of rows modified since this table was last analyzed
  int64 heap_blks_read = 18;      // Number of disk blocks read from this table
  int64 heap_blks_hit = 19;       // Number of buffer hits in this table
  int64 idx_blks_read = 20;       // Number of disk blocks read from all indexes on this table
  int64 idx_blks_hit = 21;        // Number of buffer hits in all indexes on this table
  int64 toast_blks_read = 22;     // Number of disk blocks read from this table's TOAST table (if any)
  int64 toast_blks_hit = 23;      // Number of buffer hits in this table's TOAST table (if any)
  int64 tidx_blks_read = 24;      // Number of disk blocks read from this table's TOAST table indexes (if any)
  int64 tidx_blks_hit = 25;       // Number of buffer hits in this table's TOAST table indexes (if any)
}

message RelationEvent {
  enum EventType {
    MANUAL_VACUUM = 0;  // Manually vacuumed (not counting VACUUM FULL)
    AUTO_VACUUM = 1;    // Vacuumed by the autovacuum daemon
    MANUAL_ANALYZE = 2; // Manually analyzed
    AUTO_ANALYZE = 3;   // Analyzed by the autovacuum daemon
  }

  int32 relation_idx = 1;
  EventType type = 2;
  google.protobuf.Timestamp occurred_at = 3;
  bool approximate_occurred_at = 4; // In case the "occurred_at" field is approximate, because more than one kind of this event happened during the snapshot
}

message RelationBloatStatistic {
  int32 relation_idx = 1;

  int64 wasted_bytes = 2;
  int64 size_bytes = 3;
}

message IndexInformation {
  int32 index_idx = 1;
  int32 relation_idx = 2;

  repeated int32 columns = 3;
  string index_def = 4;
  NullString constraint_def = 5;

  bool is_primary = 6;
  bool is_unique = 7;
  bool is_valid = 8;
  int32 fillfactor = 9;
  string index_type = 10;
}

message IndexStatistic {
  int32 index_idx = 1;

  int64 size_bytes = 2;
  int64 idx_scan = 3;
  int64 idx_tup_read = 4;
  int64 idx_tup_fetch = 6;
  int64 idx_blks_read = 7;
  int64 idx_blks_hit = 8;
}

message IndexBloatStatistic {
  int32 index_idx = 1;

  int64 wasted_bytes = 2;
  int64 size_bytes = 3;
}
message FunctionInformation {
  int32 function_idx = 1;

  string language = 3;
  string source = 4;
  string source_bin = 5;
  repeated string config = 6;
  string result = 8;

  bool aggregate = 9;
  bool window = 10;
  bool security_definer = 11;
  bool leakproof = 12;
  bool strict = 13;
  bool returns_set = 14;
  string volatile = 15;
}

message FunctionStatistic {
  int32 function_idx = 1;

  int64 calls = 2;
  double total_time = 3;
  double self_time = 4;
}
